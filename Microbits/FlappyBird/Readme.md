## Step 1: Add the Bird to the Game
First, we are going to add a sprite for the bird from the Game menu and make it blink.
```
bird: game.LedSprite = None
bird = game.create_sprite(0, 2)
bird.set(LedSpriteProperty.BLINK, 300)
```
## Step 2: Make the Bird fly
Before creating the code for the game actions, let’s first add some controls so that we can move around. We’ll control the bird by pressing the A button to go up or the B button to go down.
```
bird: game.LedSprite = None

def on_button_pressed_a():
    bird.change(LedSpriteProperty.Y, -1)
input.on_button_pressed(Button.A, on_button_pressed_a)

def on_button_pressed_b():
    bird.change(LedSpriteProperty.Y, 1)
input.on_button_pressed(Button.B, on_button_pressed_b)
```
## Step 3: Generating obstacles
This is where things will start to get interesting. We’re going to randomly generate obstacles. We’ll keep all obstacles inside the array. All obstacles will have a single hole for the bird to fly through.

First, create an array of obstacles which will hold all of the obstacle sprites.
```
obstacles: List[game.LedSprite] = []
```
Now generate vertical obstacles consisting of 4 sprites and 1 random hole. Create new variable called emptyObstacleY. Using pick random, generate a random number from 0 to 4 and store it inside emptyObstacleY.

Using for loop, iterate from 0 to 4. For every coordinate not equal to emptyObstacleY create and add obstacle sprites to the end of the obstacles array.

```
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []
emptyObstacleY = randint(0, 4)
for index in range(5):
    if index != emptyObstacleY:
        obstacles.append(game.create_sprite(4, index))
```
Now with every micro:bit restart you should see different autogenerated vertical obstacles.

Before continuing, make sure that obstacles are generated randomly and that the bird is moving up and down.

```
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []
bird: game.LedSprite = None
bird = game.create_sprite(0, 2)
bird.set(LedSpriteProperty.BLINK, 300)
emptyObstacleY = randint(0, 4)
for index in range(5):
    if index != emptyObstacleY:
        obstacles.append(game.create_sprite(4, index))

def on_button_pressed_a():
    bird.change(LedSpriteProperty.Y, -1)
input.on_button_pressed(Button.A, on_button_pressed_a)

def on_button_pressed_b():
    bird.change(LedSpriteProperty.Y, 1)
input.on_button_pressed(Button.B, on_button_pressed_b)
```

Step 4: Make obstacles move
Access each obstacle using a for element loop (iterate over the obstacles array) and decrease the obstacle X coordinate by 1. Right click on the value block and rename it to obstacle ; then drag that obstacle block on top of sprite in the change x block.
```
obstacles: List[game.LedSprite] = []

def on_forever():
    for obstacle in obstacles:
        obstacle.change(LedSpriteProperty.X, -1)
    basic.pause(1000)
basic.forever(on_forever)
```
Step 5: Make obstacles disappear
Make obstacles disappear after reaching leftmost corner. Iterate over all obstacles, delete the obstacle sprites where the X coordinate equals 0, and remove them from the obstacles array.
```
obstacles: List[game.LedSprite] = []

def on_forever():
    while len(obstacles) > 0 and obstacles[0].get(LedSpriteProperty.X) == 0:
        obstacles.remove_at(0).delete()
    for obstacle in obstacles:
        obstacle.change(LedSpriteProperty.X, -1)
    basic.pause(1000)
basic.forever(on_forever)
```
Step 6: Generate more obstacles
At the moment, our code generates just one vertical obstacle. We need to put obstacle generation code into the forever loop so that it keeps generating more and more obstacles.

```
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []

def on_forever():
    global emptyObstacleY
    while len(obstacles) > 0 and obstacles[0].get(LedSpriteProperty.X) == 0:
        obstacles.remove_at(0).delete()
    for obstacle in obstacles:
        obstacle.change(LedSpriteProperty.X, -1)
    emptyObstacleY = randint(0, 4)
    for index in range(5):
        if index != emptyObstacleY:
            obstacles.append(game.create_sprite(4, index))
    basic.pause(1000)
basic.forever(on_forever)
```
Now our screen is full of moving obstacles. Create some spaces between generated obstacles. Let’s introduce a ticks variable to count how many iterations the forever loop has done and execute obstacle creation only if ticks is divisible by 3.
```
ticks = 0
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []

def on_forever():
    global emptyObstacleY, ticks
    while len(obstacles) > 0 and obstacles[0].get(LedSpriteProperty.X) == 0:
        obstacles.remove_at(0).delete()
    for obstacle in obstacles:
        obstacle.change(LedSpriteProperty.X, -1)
    if ticks % 3 == 0:
        emptyObstacleY = randint(0, 4)
        for index in range(5):
            if index != emptyObstacleY:
                obstacles.append(game.create_sprite(4, index))
    ticks += 1
    basic.pause(1000)
basic.forever(on_forever)
```
## Step 7: Game Over
Right now nothing happens when the bird is hit by obstacle. Fix this by iterating over the obstacles array and checking if any obstacle sprite coordinate equals the bird coordinate.
```
bird: game.LedSprite = None
ticks = 0
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []

def on_forever():
    global emptyObstacleY, ticks
    while len(obstacles) > 0 and obstacles[0].get(LedSpriteProperty.X) == 0:
        obstacles.remove_at(0).delete()
    for obstacle in obstacles:
        obstacle.change(LedSpriteProperty.X, -1)
    if ticks % 3 == 0:
        emptyObstacleY = randint(0, 4)
        for index in range(5):
            if index != emptyObstacleY:
                obstacles.append(game.create_sprite(4, index))
    for obstacle2 in obstacles:
        if obstacle2.get(LedSpriteProperty.X) == bird.get(LedSpriteProperty.X) and obstacle2.get(LedSpriteProperty.Y) == bird.get(LedSpriteProperty.Y):
            game.game_over()
    ticks += 1
    basic.pause(1000)
basic.forever(on_forever)
```
## Final Code
```
ticks = 0
emptyObstacleY = 0
obstacles: List[game.LedSprite] = []
index = 0
bird: game.LedSprite = None

def on_button_pressed_a():
    bird.change(LedSpriteProperty.Y, -1)
input.on_button_pressed(Button.A, on_button_pressed_a)

def on_button_pressed_b():
    bird.change(LedSpriteProperty.Y, 1)
input.on_button_pressed(Button.B, on_button_pressed_b)

index = 0
obstacles = []
bird = game.create_sprite(0, 2)
bird.set(LedSpriteProperty.BLINK, 300)

def on_forever():
    global emptyObstacleY, ticks
    while len(obstacles) > 0 and obstacles[0].get(LedSpriteProperty.X) == 0:
        obstacles.remove_at(0).delete()
    for obstacle2 in obstacles:
        obstacle2.change(LedSpriteProperty.X, -1)
    if ticks % 3 == 0:
        emptyObstacleY = randint(0, 4)
        for index2 in range(5):
            if index2 != emptyObstacleY:
                obstacles.append(game.create_sprite(4, index2))
    for obstacle3 in obstacles:
        if obstacle3.get(LedSpriteProperty.X) == bird.get(LedSpriteProperty.X) and obstacle3.get(LedSpriteProperty.Y) == bird.get(LedSpriteProperty.Y):
            game.game_over()
    ticks += 1
    basic.pause(1000)
basic.forever(on_forever)
```
## Challenge
Here are some additional features you can add to the game:

* Count and show the Crashy Bird game score.
* Make the obstacles move faster every time an obstacle is passed.
